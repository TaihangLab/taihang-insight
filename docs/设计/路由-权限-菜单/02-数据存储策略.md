# 数据存储策略

> 太行视觉AI平台 - Pinia Store 模块与 localStorage 持久化策略

---

## 目录

- [1. 模块化存储架构](#1-模块化存储架构)
- [2. Store 模块详解](#2-store-模块详解)
- [3. 持久化配置](#3-持久化配置)
- [4. 数据读取策略](#4-数据读取策略)
- [5. 数据同步机制](#5-数据同步机制)

---

## 1. 模块化存储架构

### 1.1 存储映射表

系统使用**独立的 Store 模块**，每个模块单独持久化到 localStorage：

| Store | 模块文件 | localStorage Key | 存储内容 | 类型 |
|-------|---------|-----------------|----------|------|
| **Token** | `token.ts` | `taihang-token` | `{ token: string }` | 认证令牌 |
| **UserInfo** | `userInfo.ts` | `taihang-user-info` | `{ userInfo: UserInfo }` | 用户信息 |
| **Permissions** | `permissions.ts` | `taihang-permissions` | `{ permissions: string[] }` | 权限码列表 |
| **Menus** | `menus.ts` | `taihang-menus` | `{ menuTree: MenuItem[] }` | 菜单树 |

### 1.2 存储架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    Pinia Stores (内存)                      │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │  Token   │  │ UserInfo │  │Permission│  │  Menus   │   │
│  │  Store   │  │  Store   │  │  Store   │  │  Store   │   │
│  │  (token) │  │(userInfo)│  │(permissions)│(menuTree) │  │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘   │
│       │             │             │             │          │
└───────┼─────────────┼─────────────┼─────────────┼──────────┘
        │             │             │             │
        ▼             ▼             ▼             ▼
┌─────────────────────────────────────────────────────────────┐
│         pinia-plugin-persistedstate (自动同步)               │
│              ↓ persist.state (序列化)                        │
└─────────────────────────────────────────────────────────────┘
        │             │             │             │
        ▼             ▼             ▼             ▼
┌─────────────────────────────────────────────────────────────┐
│                    localStorage (持久化)                     │
│  ┌──────────────┬──────────────┬──────────────┬──────────┐ │
│  │taihang-token │taihang-user- │taihang-perms │taihang-  │ │
│  │              │info          │              │menus     │ │
│  │'eyJhbGc...'  │{...JSON...}  │[...array...] │{...JSON..}│ │
│  └──────────────┴──────────────┴──────────────┴──────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 1.3 架构优势

| 特性 | 说明 |
|-----|------|
| **关注点分离** | 每个模块只管理自己的数据 |
| **独立持久化** | 可以单独控制每个模块的持久化策略 |
| **类型安全** | 每个模块都有明确的类型定义 |
| **易于测试** | 模块独立，便于单元测试 |
| **按需清除** | 登出时可选择性清除数据 |

---

## 2. Store 模块详解

### 2.1 Token Store

**文件**: `src/stores/modules/token.ts`

```typescript
import { defineStore } from 'pinia'
import { ref } from 'vue'

export const useTokenStore = defineStore('token', () => {
  // ========== 状态 ==========
  const token = ref('')

  // ========== 方法 ==========
  function setToken(newToken: string) {
    token.value = newToken
  }

  function clearToken() {
    token.value = ''
  }

  function hasToken(): boolean {
    return !!token.value
  }

  return {
    token,
    setToken,
    clearToken,
    hasToken
  }
}, {
  // ========== 持久化配置 ==========
  persist: {
    key: 'taihang-token',
    storage: localStorage
  }
})
```

**职责**：
- 管理 JWT Token 字符串
- 提供认证状态检查（`hasToken()`）
- 提供 token 清除方法（登出时使用）

**使用示例**：
```typescript
import { useTokenStore } from '@/stores'

const tokenStore = useTokenStore()

// 设置 token
tokenStore.setToken('eyJhbGciOiJ...')

// 检查是否登录
if (tokenStore.hasToken()) {
  console.log('已登录')
}

// 清除 token (登出)
tokenStore.clearToken()
```

---

### 2.2 UserInfo Store

**文件**: `src/stores/modules/userInfo.ts`

```typescript
import { defineStore } from 'pinia'
import { ref } from 'vue'
import type { UserInfo } from '@/types/auth'
import { StorageKey } from '@/stores/modules/storageKeys'

export const useUserInfoStore = defineStore('userInfo', () => {
  // ========== 状态 ==========
  const userInfo = ref<UserInfo | null>(null)

  // ========== 方法 ==========
  function setUserInfo(info: UserInfo) {
    userInfo.value = info
  }

  function clearUserInfo() {
    userInfo.value = null
  }

  function getNickName(): string {
    return userInfo.value?.nick_name || userInfo.value?.user_name || ''
  }

  function getUserId(): number {
    return userInfo.value?.id || userInfo.value?.user_id || 0
  }

  return {
    userInfo,
    setUserInfo,
    clearUserInfo,
    getNickName,
    getUserId
  }
}, {
  // ========== 持久化配置 ==========
  persist: {
    key: StorageKey.USER_INFO,  // 'taihang-user-info'
    storage: localStorage
  }
})
```

**UserInfo 类型定义**：
```typescript
interface UserInfo {
  id?: number
  user_id?: number
  username?: string
  user_name?: string
  nick_name?: string
  email?: string
  phone?: string
  avatar?: string
  tenantId?: number
  tenant_id?: number
  dept_id?: number
  position_id?: number
  status?: number
  gender?: string
}
```

**职责**：
- 管理用户基本信息
- 提供用户属性访问方法（昵称、ID 等）

**使用示例**：
```typescript
import { useUserInfoStore } from '@/stores'

const userInfoStore = useUserInfoStore()

// 设置用户信息
userInfoStore.setUserInfo({
  user_id: 1,
  user_name: 'admin',
  nick_name: '管理员',
  email: 'admin@example.com',
  tenant_id: 1
})

// 获取用户昵称
const nickname = userInfoStore.getNickName()
console.log(nickname)  // '管理员'

// 获取用户 ID
const userId = userInfoStore.getUserId()
console.log(userId)  // 1
```

---

### 2.3 Permissions Store

**文件**: `src/stores/modules/permissions.ts`

```typescript
import { defineStore } from 'pinia'
import { ref } from 'vue'
import { StorageKey } from '@/stores/modules/storageKeys'

export const usePermissionsStore = defineStore('permissions', () => {
  // ========== 状态 ==========
  const permissions = ref<string[]>([])

  // ========== 方法 ==========
  function setPermissions(perms: string[]) {
    permissions.value = perms
  }

  function clearPermissions() {
    permissions.value = []
  }

  /**
   * 检查是否有某个权限
   * @param permission 权限码，如 'monitor:realtime:page'
   */
  function hasPermission(permission: string): boolean {
    return permissions.value.includes(permission)
  }

  /**
   * 检查是否有多个权限中的任意一个
   * @param perms 权限码数组
   */
  function hasAnyPermission(perms: string[]): boolean {
    return perms.some(p => permissions.value.includes(p))
  }

  /**
   * 检查是否有所有指定的权限
   * @param perms 权限码数组
   */
  function hasAllPermissions(perms: string[]): boolean {
    return perms.every(p => permissions.value.includes(p))
  }

  /**
   * 获取所有权限码
   */
  function getAllPermissions(): string[] {
    return permissions.value
  }

  return {
    permissions,
    setPermissions,
    clearPermissions,
    hasPermission,
    hasAnyPermission,
    hasAllPermissions,
    getAllPermissions
  }
}, {
  // ========== 持久化配置 ==========
  persist: {
    key: StorageKey.PERMISSION,  // 'taihang-permissions'
    storage: localStorage
  }
})
```

**职责**：
- 管理用户权限码列表
- 提供权限检查方法（单个、任意一个、全部）

**使用示例**：
```typescript
import { usePermissionsStore } from '@/stores'

const permissionsStore = usePermissionsStore()

// 设置权限列表
permissionsStore.setPermissions([
  'monitor:realtime:page',
  'monitor:alarm:handle',
  'system:user:add',
  'system:user:edit'
])

// 检查单个权限
if (permissionsStore.hasPermission('monitor:realtime:page')) {
  console.log('可以访问实时监控页面')
}

// 检查多个权限（满足其一即可）
if (permissionsStore.hasAnyPermission(['system:user:add', 'system:user:edit'])) {
  console.log('可以添加或编辑用户')
}

// 检查多个权限（必须全部满足）
if (permissionsStore.hasAllPermissions(['skill:device:add', 'skill:device:edit'])) {
  console.log('可以添加和编辑设备技能')
}
```

---

### 2.4 Menus Store

**文件**: `src/stores/modules/menus.ts`

```typescript
import { defineStore } from 'pinia'
import { ref } from 'vue'
import type { MenuItem } from '@/types/auth'
import { StorageKey } from '@/stores/modules/storageKeys'

export const useMenusStore = defineStore('menus', () => {
  // ========== 状态 ==========
  const menuTree = ref<MenuItem[]>([])

  // ========== 方法 ==========
  function setMenuTree(menu: MenuItem[] | null | undefined) {
    if (Array.isArray(menu)) {
      menuTree.value = menu
    } else {
      menuTree.value = []
    }
  }

  function clearMenuTree() {
    menuTree.value = []
  }

  /**
   * 查找第一个可访问的菜单路径
   * 用于登录后默认跳转
   */
  function findFirstAccessibleMenu(): string | null {
    // 递归查找第一个 menu 类型的菜单
    function findFirst(items: MenuItem[]): string | null {
      for (const item of items) {
        const menuType = item.menu_type || item.permission_type || item.type
        if ((menuType === 'menu' || menuType === 1) && item.path) {
          return item.path
        }
        if (item.children?.length) {
          const found = findFirst(item.children)
          if (found) return found
        }
      }
      return null
    }

    return findFirst(menuTree.value)
  }

  /**
   * 提取所有可访问的路由路径
   */
  function getAccessibleRoutes(): string[] {
    const routes: string[] = []

    function extractRoutes(items: MenuItem[]) {
      for (const item of items) {
        const menuType = item.menu_type || item.permission_type || item.type
        if ((menuType === 'menu' || menuType === 1) && item.path) {
          routes.push(item.path)
        }
        if (item.children?.length) {
          extractRoutes(item.children)
        }
      }
    }

    extractRoutes(menuTree.value)
    return routes
  }

  /**
   * 检查是否有某个菜单路径的访问权限
   */
  function hasMenuPath(path: string): boolean {
    return getAccessibleRoutes().includes(path)
  }

  return {
    menuTree,
    setMenuTree,
    clearMenuTree,
    findFirstAccessibleMenu,
    getAccessibleRoutes,
    hasMenuPath
  }
}, {
  // ========== 持久化配置 ==========
  persist: {
    key: StorageKey.MENUS,  // 'taihang-menus'
    storage: localStorage
  }
})
```

**MenuItem 类型定义**：
```typescript
interface MenuItem {
  id: number
  menu_name?: string
  permission_name?: string
  name?: string
  menu_type?: string | number
  permission_type?: string | number
  type?: string | number
  icon?: string
  path?: string
  sort_order?: number
  status?: number
  visible?: boolean
  children?: MenuItem[]
}
```

**职责**：
- 管理用户菜单树
- 提供菜单查询方法（首个可访问菜单、所有路由、路径检查）

**使用示例**：
```typescript
import { useMenusStore } from '@/stores'

const menusStore = useMenusStore()

// 设置菜单树
menusStore.setMenuTree([
  {
    id: 1,
    menu_name: '监控预警',
    menu_type: 'folder',
    icon: 'VideoCamera',
    path: '/monitoring',
    children: [
      {
        id: 11,
        menu_name: '实时监控',
        menu_type: 'menu',
        path: '/monitoring/realtime'
      }
    ]
  }
])

// 查找第一个可访问菜单
const firstMenu = menusStore.findFirstAccessibleMenu()
console.log(firstMenu)  // '/monitoring/realtime'

// 获取所有可访问路由
const routes = menusStore.getAccessibleRoutes()
console.log(routes)  // ['/monitoring/realtime']

// 检查是否有某个路径的权限
if (menusStore.hasMenuPath('/monitoring/realtime')) {
  console.log('可以访问实时监控')
}
```

---

### 2.5 StorageKey 常量定义

**文件**: `src/stores/modules/storageKeys.ts`

```typescript
/**
 * localStorage 键名常量
 */
export enum StorageKey {
  /** 认证令牌 */
  ADMIN_TOKEN = 'taihang-token',

  /** 用户信息 */
  USER_INFO = 'taihang-user-info',

  /** 权限列表 */
  PERMISSION = 'taihang-permissions',

  /** 菜单树 */
  MENUS = 'taihang-menus'
}
```

**使用原则**：
- 所有 localStorage 键名统一使用 `taihang-` 前缀
- 使用枚举避免字符串硬编码
- 便于全局管理和重命名

---

## 3. 持久化配置

### 3.1 持久化插件配置

**文件**: `src/main.ts`

```typescript
import { createPinia } from 'pinia'
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'

const pinia = createPinia()
pinia.use(piniaPluginPersistedstate)

app.use(pinia)
```

### 3.2 持久化工作原理

```
┌─────────────────────────────────────────────────────────────┐
│                    Pinia Store                              │
│                                                              │
│  const token = ref('eyJhbGciOi...')                        │
│                                                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  persist: {                                         │   │
│  │    key: 'taihang-token',                           │   │
│  │    storage: localStorage                           │   │
│  │  }                                                 │   │
│  └─────────────────────────────────────────────────────┘   │
└────────────────────────────┬────────────────────────────────┘
                             │
        ┌────────────────────┴────────────────────┐
        │                                         │
        ▼                                         ▼
┌───────────────────┐                   ┌───────────────────┐
│  token.value 变化  │                   │  应用启动时        │
│  (setToken)       │                   │  读取 localStorage  │
└─────────┬─────────┘                   └─────────┬─────────┘
          │                                       │
          ▼                                       ▼
┌─────────────────────────────────────────────────────────────┐
│         pinia-plugin-persistedstate                        │
│         自动监听状态变化 → 序列化 → 写入 localStorage      │
└─────────────────────────────────────────────────────────────┘
          │                                       │
          ▼                                       ▼
┌─────────────────────────────────────────────────────────────┐
│                    localStorage                             │
│  taihang-token: 'eyJhbGciOi...'                           │
└─────────────────────────────────────────────────────────────┘
```

### 3.3 持久化时机

| 触发条件 | 动作 | 说明 |
|---------|------|------|
| **状态变化** | 自动写入 | 任何 ref 值变化都会触发持久化 |
| **应用启动** | 自动读取 | Store 初始化时从 localStorage 恢复 |
| **状态清除** | 自动删除 | 调用 clear 方法时自动删除 |

---

## 4. 数据读取策略

### 4.1 核心原则

**⚠️ 重要**: 所有数据必须通过 **Store** 读取，localStorage 是持久化插件的内部实现细节。

```
数据流方向（单向）：
后端 API → Store → localStorage（持久化插件自动处理）
      ↑
      └── 唯一数据读取入口
```

| 场景 | 正确做法 | 错误做法 |
|-----|---------|---------|
| **组件中读取数据** | `const token = tokenStore.token` | ❌ `localStorage.getItem('...')` |
| **检查登录状态** | `if (tokenStore.hasToken())` | ❌ `if (localStorage.getItem(...))` |
| **获取用户信息** | `const info = userInfoStore.userInfo` | ❌ `JSON.parse(localStorage.getItem(...))` |
| **获取权限列表** | `const perms = permissionsStore.permissions` | ❌ 手动从 localStorage 解析 |

### 4.2 正确的数据读取方式

```typescript
// ✅ 正确：从 Store 读取
import { useTokenStore, useUserInfoStore } from '@/stores'

const tokenStore = useTokenStore()
const userInfoStore = useUserInfoStore()

// 读取 token
const token = tokenStore.token

// 检查是否登录
if (tokenStore.hasToken()) {
  console.log('已登录')
}

// 读取用户信息
const userName = userInfoStore.userInfo?.user_name
```

### 4.3 特殊场景：路由守卫

**唯一例外**：路由守卫中可能需要直接读取 localStorage，因为守卫在 Pinia 完全初始化前执行。

```typescript
// ⚠️ 仅在路由守卫中使用
function getTokenFromStorage(): string | null {
  try {
    const token = localStorage.getItem(StorageKey.ADMIN_TOKEN)
    return token || null
  } catch {
    return null
  }
}

router.beforeEach((to, _from, next) => {
  // 白名单检查
  const whiteList = ['/login', '/test']
  if (whiteList.some(path => to.path.startsWith(path))) {
    next()
    return
  }

  // 认证检查（特殊场景：直接从 localStorage 读取）
  const token = getTokenFromStorage()
  if (!token) {
    next({ path: '/login', query: { redirect: to.fullPath } })
    return
  }

  next()
})
```

**为什么路由守卫是例外？**
- 路由守卫在应用初始化时同步执行
- Pinia 持久化插件可能还未完成异步恢复
- 需要保证认证检查的同步性和可靠性

### 4.2 路由守卫中的读取

**文件**: `src/router/index.ts`

```typescript
/**
 * 从 localStorage 获取 token
 * 在路由守卫中直接读取，避免 Pinia 初始化延迟
 */
function getTokenFromStorage(): string | null {
  try {
    const token = localStorage.getItem(StorageKey.ADMIN_TOKEN)
    return token || null
  } catch {
    return null
  }
}

router.beforeEach((to, _from, next) => {
  // 白名单检查
  const whiteList = ['/login', '/test', '/play/wasm', '/play/rtc']
  if (whiteList.some(path => to.path.startsWith(path))) {
    next()
    return
  }

  // 认证检查（直接从 localStorage 读取）
  const token = getTokenFromStorage()
  if (!token) {
    next({ path: '/login', query: { redirect: to.fullPath } })
    return
  }

  next()
})
```

**为什么在路由守卫中直接读取 localStorage？**
- Pinia 持久化插件可能还未完成初始化
- 避免异步初始化导致的认证判断错误
- 保证守卫同步执行

### 4.4 应用启动时的数据初始化

**重要**: 不需要手动从 localStorage 读取！持久化插件会自动恢复数据。

**正确流程**：

```typescript
// main.ts
import { useMenusStore } from '@/stores'

const menusStore = useMenusStore()

// 应用启动时初始化
onMounted(async () => {
  // ✅ 持久化插件已自动从 localStorage 恢复到 menusStore.menuTree
  // ✅ 如果恢复的数据为空，才从 API 获取
  if (menusStore.menuTree.length === 0) {
    // 调用 API 获取最新数据
    const result = await authAPI.getMenuTree()
    if (result.code === 200) {
      menusStore.setMenuTree(result.data.menu_tree)
      // ← setMenuTree 后，持久化插件会自动写入 localStorage
    }
  }

  // 使用 Store 中的数据生成动态路由
  setupAsyncRoutes(menusStore.menuTree)
})
```

**数据流说明**：

```
应用启动
    │
    ▼
Pinia Store 初始化
    │
    ├─→ pinia-plugin-persistedstate
    │       │
    │       ▼
    │   从 localStorage 读取
    │       │
    │       ▼
    │   恢复到 menusStore.menuTree
    │
    ▼
检查 menusStore.menuTree.length
    │
    ├─→ > 0 (有数据)
    │       │
    │       ▼
    │   直接使用（来自 localStorage）
    │
    └─→ = 0 (无数据)
            │
            ▼
        调用 API 获取
            │
            ▼
        menusStore.setMenuTree()
            │
            ▼
        持久化插件自动写入 localStorage
```

**关键点**：
1. ✅ **不需要手动读取 localStorage** - 持久化插件自动处理
2. ✅ **Store 是唯一数据源** - 始终从 Store 读取
3. ✅ **API 无缓存** - 每次都需要调用获取最新数据
4. ✅ **持久化自动同步** - Store 变化自动同步到 localStorage

---

## 5. 数据同步机制

### 5.1 自动同步流程

```
┌─────────────────────────────────────────────────────────────┐
│                    用户操作                                  │
│                  (登录/登出/更新)                            │
└────────────────────────────┬────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────┐
│                 调用 Store 方法                              │
│         tokenStore.setToken(newToken)                       │
└────────────────────────────┬────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────┐
│               Pinia 响应式状态更新                           │
│              token.value = newToken                         │
└────────────────────────────┬────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────┐
│         pinia-plugin-persistedstate 监听变化                 │
│                  (自动 hook)                                 │
└────────────────────────────┬────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────┐
│              序列化并写入 localStorage                       │
│      localStorage.setItem('taihang-token', newToken)        │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 数据清除流程

**登出场景**：

```typescript
async function logout() {
  // 1. 清除所有 Store 数据
  tokenStore.clearToken()           // → 删除 taihang-token
  userInfoStore.clearUserInfo()     // → 删除 taihang-user-info
  permissionsStore.clearPermissions() // → 删除 taihang-permissions
  menusStore.clearMenuTree()         // → 删除 taihang-menus

  // 2. 重置动态路由
  resetAsyncRoutes()

  // 3. 跳转到登录页
  router.push('/login')
}
```

**localStorage 变化**：
```
清除前:
├── taihang-token: 'eyJhbGciOi...'
├── taihang-user-info: '{...}'
├── taihang-permissions: '[...]'
└── taihang-menus: '{...}'

清除后:
└── (全部删除)
```

### 5.3 数据一致性保证

| 场景 | 保证机制 |
|-----|---------|
| **状态更新** | Pinia 响应式系统 + 持久化插件自动同步 |
| **应用刷新** | 持久化插件自动从 localStorage 恢复状态 |
| **多标签页** | localStorage 跨标签页共享，需手动同步 |
| **并发写入** | Pinia 状态队列保证顺序 |

---

## 6. 存储限制与注意事项

### 6.1 localStorage 限制

| 限制项 | 说明 | 应对 |
|-------|------|------|
| **容量** | 约 5-10MB | 避免存储大数据（如图片、视频） |
| **同步阻塞** | 读写是同步操作 | 避免频繁写入大量数据 |
| **仅支持字符串** | 需要序列化/反序列化 | 插件自动处理 JSON |
| **同源策略** | 仅同源可访问 | 符合安全要求 |

### 6.2 存储数据大小估算

```
Token:        ~500 bytes   (JWT 字符串)
UserInfo:     ~1 KB        (用户基本信息)
Permissions:  ~5 KB        (约 100-200 个权限码)
Menus:        ~20 KB       (完整的菜单树结构)
─────────────────────────────────────
总计:         ~26.5 KB    (远低于限制)
```

### 6.3 最佳实践

| 实践 | 说明 |
|-----|------|
| ✅ 只存储必要数据 | 避免存储冗余或临时数据 |
| ✅ 使用 StorageKey 枚举 | 避免硬编码字符串 |
| ✅ 定期清理过期数据 | 避免累积无用数据 |
| ✅ 敏感数据加密 | Token 已是加密格式，但注意其他数据 |
| ❌ 避免存储大量数据 | 如日志、缓存等应使用 IndexedDB |
| ❌ 避免频繁写入 | 利用 Pinia 批量更新机制 |

---

**下一步**: 阅读 [登录流程](./03-登录流程.md) 了解用户认证的完整流程
